package com.github.ros.roxanne_sa.ai.deliberative.solver;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.atomic.AtomicInteger;

import com.github.ros.roxanne_sa.ai.framework.domain.component.Decision;
import com.github.ros.roxanne_sa.ai.framework.domain.component.DomainComponent;
import com.github.ros.roxanne_sa.ai.framework.microkernel.lang.flaw.Flaw;
import com.github.ros.roxanne_sa.ai.framework.microkernel.lang.flaw.FlawType;
import com.github.ros.roxanne_sa.ai.framework.microkernel.lang.plan.Plan;

/**
 * 
 * @author anacleto
 *
 */
public class SearchSpaceNode implements Comparable<SearchSpaceNode>
{
	private static final AtomicInteger ID_COUNTER = new AtomicInteger(0);
	
	private int id;												// node unique ID
	private List<Operator> operators;							// node generation trace
	
	private Map<DomainComponent, List<DecisionVariable>> plan;	// partial plan
 	private Map<DomainComponent, List<Flaw>> agenda; 			// flaws associated to the resulting partial plan
 	
 	private double[] makespan;									// average makespan of timelines
 	private double[] duration;									// average duration of timelines
	private double cost; 										// node generation cost
	private double heuristic;									// node heuristic estimation (e.g., planning distance)
	
	private Object domainSpecificMetric;						// node domain specific metric
	
	/**
	 * 
	 */
	protected SearchSpaceNode() {
		// set node's id
		this.id = ID_COUNTER.getAndIncrement();
		// set operators
		this.operators = new ArrayList<>();
		// set default heuristic estimation
		this.heuristic = 0;
		// set plan generation cost 
		this.cost = 0.0;
		// set agenda
		this.agenda = new HashMap<>();
		
		this.makespan = new double[] {
				Double.MAX_VALUE - 1,
				Double.MAX_VALUE - 1
		};
		
		this.duration = new double[] {
				Double.MAX_VALUE - 1,
				Double.MAX_VALUE - 1
		};
		
		// set additional metric
		this.domainSpecificMetric = null;
	}
	
	/**
	 * Create a child node generated by means of the specified operator
	 * 
	 * @param parent
	 * @param op
	 */
	protected SearchSpaceNode(SearchSpaceNode parent, Operator op) {
		this();
		// set operators
		this.operators = new ArrayList<>(parent.getOperators());
		// add generator
		this.operators.add(op);
		
		// set default heuristic estimation
		this.heuristic = 0;
		// update plan generation cost
		this.cost = parent.getCost() + op.getCost();
		// set agenda
		this.agenda = new HashMap<>();
		
		this.makespan = new double[] {
				Double.MAX_VALUE - 1,
				Double.MAX_VALUE - 1
		};
		
		this.duration = new double[] {
				Double.MAX_VALUE - 1,
				Double.MAX_VALUE - 1
		};
		
		// set additional metric
		this.domainSpecificMetric = null;
	}
	
	
	/**
	 * 
	 * @return
	 */
	public int getId() {
		return id;
	}
	
	/**
	 * 
	 * @param metric
	 */
	public void setDomainSpecificMetric(Object metric) {
		this.domainSpecificMetric = metric;
	}
	
	/**
	 * 
	 * @return
	 */
	public Object getDomainSpecificMetric() {
		return domainSpecificMetric;
	}
	
	/**
	 * 
	 * @param flaw
	 * @return
	 */
	public void addCheckedFlaw(Flaw flaw) {
		if (!this.agenda.containsKey(flaw.getComponent())) {
			this.agenda.put(flaw.getComponent(), new ArrayList<>());
		}
		
		// add the flaw
		this.agenda.get(flaw.getComponent()).add(flaw);
	}
	
	/**
	 * 
	 * @return
	 */
	public Set<Flaw> getAgenda() {
		Set<Flaw> list = new HashSet<>();
		for (DomainComponent comp : this.agenda.keySet()) {
			list.addAll(this.agenda.get(comp));
		}
		
		return list;
	}
	
	/**
	 * 
	 * @return
	 */
	public Set<Flaw> getFlaws(FlawType type) {
		Set<Flaw> list = new HashSet<>();
		for (DomainComponent comp : this.agenda.keySet()) {
			for (Flaw flaw : this.agenda.get(comp)) {
				// check flaw type
				if (flaw.getType().equals(type)) {
					// add the flaw
					list.add(flaw);
				}
			}
		}
		
		return list;
	}
	
	/**
	 * 
	 * @return
	 */
	public int getNumberOfFlaws() {
		int number = 0;
		for (List<Flaw> list : this.agenda.values()) {
			number += list.size();
		}
		return number;
	}
	
	
	/**
	 * 
	 * @param comp
	 * @return
	 */
	public Set<Flaw> getFlaws(DomainComponent comp) {
		return new HashSet<>(this.agenda.get(comp));
	}
	
	/**
	 * 
	 * @return
	 */
	public int getDepth() {
		return this.operators.size();
	}
		
	/**
	 * 
	 * @return
	 */
	public double getHeuristic() {
		return heuristic;
	}
	
	/**
	 * 
	 * @param heuristic
	 */
	public void setHeuristic(double heuristic) {
		this.heuristic = heuristic;
	
	}
	
	/**
	 * 
	 * @param partialPlan
	 */
	public void setPartialPlan(Plan partialPlan) 
	{
		// set the partial plan 
		this.plan = new HashMap<>();
		// check decisions
		for (Decision dec : partialPlan.getDecisions()) {
			if (!this.plan.containsKey(dec.getComponent())) {
				// add entry 
				this.plan.put(dec.getComponent(), new ArrayList<>());
			}
			
			// add decision variable
			this.plan.get(dec.getComponent()).add(new DecisionVariable(dec));
		}
		
		
		// set the makespan
		this.makespan = partialPlan.getMakespan();
		// set duration
		this.duration = partialPlan.getBehaviorDuration();
	}
	
	/**
	 * 
	 * @return
	 */
	public Map<DomainComponent, List<DecisionVariable>> getPartialPlan() {
		// set the partial plan 
		return new HashMap<>(this.plan);
	}
	
	/**
	 * 
	 * @return
	 */
	public double getCost() {
		// get the generation cost of the associated partial plan
		return this.cost;
	}
	
	/**
	 * 
	 * @return
	 */
	public double[] getMakespan() {
		return this.makespan;
	}
	
	/**
	 * 
	 * @return
	 */
	public double[] getBehaviorDuration() {
		return this.duration;
	}
	
	/**
	 * Get the flaw that has been solved to generate the node 
	 * 
	 * @return
	 */
	public Flaw getGeneratingFlaw() {
		// verify whether the node is root
		return this.isRootNode() ? null : this.getGenerator().getFlaw();
	}
	
	/**
	 * Verify whether the node is root, i.e. not generator operator has been applied.
	 * 
	 * @return
	 */
	public boolean isRootNode() {
		// check if root node
		return this.getGenerator() == null;
	}
	
	/**
	 * The method returns the order list of operators that have been applied to generated the node. 
	 * 
	 * The last operator of the list is the node generator operator (i.e. the last applied operator).
	 * 
	 * @return
	 */
	public List<Operator> getOperators() {
		// get list of operators
		return new ArrayList<>(this.operators);
	}
	
	/**
	 * The method returns the node generator operator.
	 * 
	 * The method returns null for the root node of the search space
	 * 
	 * @return
	 */
	public Operator getGenerator() 
	{
		// get generator
		Operator operator = null;
		if (!this.operators.isEmpty()) {
			// get last applied operator
			operator = this.operators.get(this.operators.size() - 1);
		}
		
		// get generator operator
		return operator;
	}
	
	/**
	 * Get the list of applied operators from the more recent to the specified one (not included).
	 * 
	 * The method returns the list of operators that have been applied after the specified one starting with the more recent. The first
	 * element of the list is the node generator operator.
	 * 
	 * @param operator
	 * @return
	 */
	public List<Operator> getOperatorsUpTo(Operator operator) {
		// list of operators
		List<Operator> list = new ArrayList<>();
		if (operator == null) {
			// add all operators
			list.addAll(this.operators);
			// reverse order
			Collections.reverse(list);
		}
		else {
			// get index of the operator
			int index = this.operators.indexOf(operator);
			for (int i = this.operators.size() - 1; i > index; i--) {
				// add operator
				list.add(this.operators.get(i));
			}
		}
		// get list of operators
		return list;
	}
	
	/**
	 * Get the list of applied operators starting from the selected operator (not included).
	 * 
	 * The method returns the orderer list of operators that have been applied after the specified one. The 
	 * last operator of the list is the node generator operator.
	 * 
	 * 
	 * @param operator
	 * @return
	 */
	public List<Operator> getOperatorsFrom(Operator operator) {
		// list of operators
		List<Operator> list = new ArrayList<>();
		if (operator == null) {
			// add all operators
			list.addAll(this.operators);
		}
		else {
			// get index of the operator
			for (int index = this.operators.indexOf(operator) + 1; index < this.operators.size(); index++) {
				// add operator
				list.add(this.operators.get(index));
			}
		}
		// get list of operators
		return list;
	}
	
	/**
	 * 
	 */
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = 1;
		result = prime * result + id;
		return result;
	}

	/**
	 * 
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		SearchSpaceNode other = (SearchSpaceNode) obj;
		if (id != other.id)
			return false;
		return true;
	}
	
	/**
	 * 
	 * @param o
	 * @return
	 */
	@Override
	public int compareTo(SearchSpaceNode o) {
		// compare nodes by their ID
		return this.cost < o.cost ? -1 : this.cost > o.cost ? 1 : 0;
	}
	
	/**
	 * 
	 */
	@Override
	public String toString() {
		return "{ "
				+ "id: " + this.id + ", "
				+ "depth: " + this.getDepth() + ", "
				+ "cost: " + this.getCost() + ", "
				+ "heuristic: " + this.heuristic + ", "
				+ "makespan: [" + this.makespan[0] + ", " + this.makespan[1] + "], "
				+ "duration: [" + this.duration[0] +", " + this.duration[1] + "], "
				+ (this.domainSpecificMetric != null ? "additional-metric: " + this.domainSpecificMetric.toString() + ", " : "")
				+ " }";
	}
}
